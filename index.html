<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matt's Puzzle</title>
    <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&display=block" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: #111;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #FFDAE9;
            overflow: auto;
            padding: 24px;
        }

        /* Envelope stage: no modal, just envelope on pink background */
        #envelopeStage {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            position: fixed;
            inset: 0;
            z-index: 10;
        }

        body.show-modal .container {
            display: flex;
        }

        .container {
            display: none;
            flex-direction: column;
            text-align: center;
            background: white;
            padding: 40px 36px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            /* Don't use fit-content here: views are layered for page-turn, so the card must have a real width */
            width: min(650px, calc(100vw - 48px));
            max-width: 100%;
            min-width: 0;
            min-height: 700px;
            max-height: calc(100vh - 48px);
            /* Views are absolutely positioned for the page-turn; scrolling must happen inside the active view */
            overflow: hidden;
            position: relative;
            transform-origin: center center;
            transition: opacity 0.25s ease, transform 0.3s ease;
            perspective: 1200px; /* enables 3D */
        }

        .modal-inner {
            flex: 1 1 auto;
            position: relative;
            width: 100%;
            max-width: 100%;
            min-height: 0;
        }

        .modal-view {
            position: absolute;
            inset: 0;
            width: 100%;
            max-width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            overflow-y: auto;
            opacity: 0;
            transform: rotateY(0deg);
            transform-origin: left center;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            transition: transform 0.75s cubic-bezier(.2,.9,.2,1), opacity 0.25s ease;
            pointer-events: none;
        }

        .modal-view.visible {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
        }

        .modal-view.turn-out {
            transform: rotateY(-180deg);
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .modal-view.turn-in {
            transform: rotateY(180deg);
            opacity: 0;
            pointer-events: auto;
            z-index: 3;
            animation: turnIn 0.75s cubic-bezier(.2,.9,.2,1) forwards;
        }

        @keyframes turnIn {
            from { transform: rotateY(180deg); opacity: 0 }
            to   { transform: rotateY(0deg); opacity: 1 }
        }

        .envelope {
            position: relative;
            width: 220px;
            height: 160px;
            background: #f5e6d3;
            border: 1px solid #d4c4a8;
            border-radius: 4px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.12);
            cursor: pointer;
            transition: transform 0.25s ease, box-shadow 0.25s ease;
        }

        .envelope:hover:not(.opening) {
            transform: scale(1.05);
            box-shadow: 0 8px 28px rgba(0,0,0,0.15);
        }

        .envelope-flap {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(165deg, #e8d5c4 0%, #d4c4a8 45%, #c9b89a 100%);
            clip-path: polygon(0 0, 50% 50%, 100% 0);
            transform-origin: top center;
            transition: transform 0.8s cubic-bezier(0.34, 1.2, 0.64, 1);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .envelope-flap-outline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .envelope-flap-outline line {
            vector-effect: non-scaling-stroke;
        }

        .envelope.opening .envelope-flap {
            transform: rotateX(-170deg);
        }

        .envelope-heart {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            color: #c41e3a;
            pointer-events: none;
            z-index: 1;
            transition: opacity 0.35s ease;
        }

        .envelope-heart.hidden {
            opacity: 0;
        }

        .envelope-heart svg {
            width: 100%;
            height: 100%;
        }

        @media (min-width: 768px) {
            .envelope {
                width: 300px;
                height: 218px;
            }
            .envelope-heart {
                width: 52px;
                height: 52px;
            }
        }

        @media (min-width: 1024px) {
            .envelope {
                width: 340px;
                height: 247px;
            }
            .envelope-heart {
                width: 58px;
                height: 58px;
            }
        }

        .envelope-stage-fade-out {
            animation: envelopeFadeOut 0.5s ease forwards;
        }

        .puzzle-stage-fade-in {
            animation: fadeIn 0.6s ease forwards;
        }

        @keyframes envelopeFadeOut {
            to { opacity: 0; transform: scale(0.96); }
        }

        .modal-view .modal-title {
            font-size: 24px;
            color: #111;
            font-weight: 500;
            line-height: 1.4;
            margin-top: 16px;
            margin-bottom: 32px;
        }

        #successView .modal-title {
            font-size: 120px;
            font-family: 'Pinyon Script', cursive;
            color: white;
            font-weight: 700;
            margin: 0 auto;
            padding: 40px 20px;
            line-height: 1.1;
            text-shadow: 
                0 0 20px rgba(137, 27, 45, 0.8),
                0 0 40px rgba(143, 27, 46, 0.6),
                2px 2px 8px rgba(130, 28, 45, 0.7),
                4px 4px 12px rgba(110, 24, 38, 0.5);
            text-align: center;
            position: relative;
            z-index: 2;
        }

        .puzzle-container {
            width: min(70vmin, 520px);
            max-width: 100%;
            margin: 0 auto;
            background: #f5f5f5;
            padding: 10px;
            border-radius: 12px;
            transition: background 0.4s ease;
        }

        .puzzle-container.completed {
            background: #fff;
        }

        .puzzle-grid-wrap {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            margin: 0 auto;
            transition: transform 0.6s cubic-bezier(0.34, 1.2, 0.64, 1);
        }

        .puzzle-grid-wrap.revealing {
            transform: scale(0.88);
            transition: transform 0.4s cubic-bezier(0.34, 1.2, 0.64, 1);
        }

        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            background: transparent;
            padding: 0;
            border-radius: 8px;
            width: 100%;
            height: 100%;
            position: absolute;
            inset: 0;
            transition: gap 0.1s ease, padding 0.1s ease, border-radius 0.1s ease;
        }

        .puzzle-grid.merging {
            gap: 0;
            padding: 0;
            border-radius: 0;
        }

        .puzzle-tile {
            min-width: 0;
            min-height: 0;
            background-size: 100% 100%;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 8px;
            cursor: pointer;
            transition: box-shadow 0.1s ease, border-radius 0.1s ease, transform 0.1s ease;
            box-shadow: 0 0px 8px rgba(0,0,0,0.15);
            position: relative;
        }

        .puzzle-tile:hover:not(.empty) {
            transform: scale(1.01);
            box-shadow: 0 0px 10px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .puzzle-grid.merging .puzzle-tile {
            box-shadow: none;
            border-radius: 0;
        }

        .puzzle-tile.empty {
            box-shadow: none;
            cursor: default;
        }

        .puzzle-full-image-overlay {
            position: absolute;
            inset: 0;
            border-radius: 8px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.25s ease;
            pointer-events: none;
        }

        .puzzle-full-image-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .puzzle-full-image-overlay img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .puzzle-tile.empty:hover {
            transform: none;
        }

        .puzzle-reveal-text {
            opacity: 0;
            transition: opacity 0.35s ease 0.1s;
            margin-top: 20px;
        }

        .puzzle-reveal-text.show {
            opacity: 1;
        }

        .puzzle-reveal-text .complete-line {
            font-size: 20px;
            color: #111;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .puzzle-reveal-text .valentine-question {
            font-size: 20px;
            color: #111;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .shuffle-button {
            margin-top: 20px;
            padding: 10px 25px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .shuffle-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Bloom-from-center effect for the final success screen */
        @keyframes successBloomIn {
            0%{
                box-shadow: inset 0 0 400px 4800px #FFDAE9;
            }
            
            100%{
                box-shadow: inset 0 0 80px 20px #FFDAE9;
            }
            
        }

        .heart {
            font-size: 4em;
            margin: 20px 0;
            animation: heartbeat 1.5s ease-in-out infinite;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.1); }
        }


        .confetti {
            position: fixed;
            font-size: 24px;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .streamer {
            position: fixed;
            font-size: 32px;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes streamer-fall {
            to {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .sparkle {
            position: fixed;
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            animation: sparkleAnim 1s ease-out;
        }

        @keyframes sparkleAnim {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotate(180deg);
                opacity: 0;
            }
        }

        /* Full-screen inset glow overlay for the final scene */
        .success-vignette {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.5s ease;
            animation: successBloomIn 8s forwards;
        }

        .success-vignette.show {
            opacity: 1;
        }

        /* Celebration effect when puzzle solved */
        @keyframes tileDisappear {
            0% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.5) rotate(180deg);
            }
        }

        .tile-disappear {
            animation: tileDisappear 0.5s ease forwards;
        }

        /* Base Yes button: defined before media queries so responsive font-size overrides apply */
        .yes-only-btn {
            font-size: 20px;
            padding: 12px 24px;
            background: #FFDAE9;
            color: #333;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 50px;
            cursor: pointer;
            margin-top: 8px;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .yes-only-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .question-buttons {
            margin-top: 8px;
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            width: 380px;
            height: 110px;
        }

        .no-run-btn {
            font-size: 18px;
            padding: 10px 22px;
            background: #ffffff;
            color: #c41e3a;
            border: 1px solid rgba(196, 30, 58, 0.5);
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            position: absolute;
            transition: left 0.18s ease, top 0.18s ease, transform 0.18s ease;
        }

        .question-emoji {
            margin-top: 90px;
            font-size: clamp(250px, 24vmin + 40px, 320px);
            line-height: 1;
            opacity: 0;
            transform: translateY(12px) scale(0.9);
            transition: opacity 0.35s ease, transform 0.35s ease;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            flex: 1 1 auto; /* let it fill most of the remaining white card */
        }

        .question-emoji.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        @media (max-width: 600px) {
            body {
                padding: 16px;
            }
            .container {
                padding: 20px 36px;
                max-width: 94%;
                min-height: 420px;
            }
            .modal-view .modal-title {
                font-size: 20px;
            }
            #successView .modal-title {
                font-size: 72px;
                margin-bottom: 40px;
            }
            .puzzle-reveal-text .complete-line,
            .puzzle-reveal-text .valentine-question {
                font-size: 18px;
            }
            .yes-only-btn {
                font-size: 18px;
            }
            .success-yay {
                font-size: 20px;
            }
            .puzzle-container {
                width: min(72vmin, 420px);
            }
        }

        @media (max-width: 420px) {
            body {
                padding: 12px;
            }
            .container {
                padding: 16px 36px;
                max-width: 96%;
                min-height: 380px;
            }
            .modal-view .modal-title {
                font-size: 18px;
            }
            #successView .modal-title {
                font-size: 56px;
                margin-bottom: 30px;
            }
            .puzzle-reveal-text .complete-line,
            .puzzle-reveal-text .valentine-question {
                font-size: 16px;
            }
            .yes-only-btn {
                font-size: 16px;
            }
            .success-yay {
                font-size: 18px;
            }
            .puzzle-container {
                width: min(76vmin, 360px);
            }
        }

        @media (max-width: 360px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 12px 36px;
                min-height: 340px;
            }
            .modal-view .modal-title {
                font-size: 16px;
            }
            #successView .modal-title {
                font-size: 44px;
                margin-bottom: 20px;
            }
            .puzzle-reveal-text .complete-line,
            .puzzle-reveal-text .valentine-question {
                font-size: 14px;
            }
            .yes-only-btn {
                font-size: 14px;
            }
            .success-yay {
                font-size: 16px;
            }
            .puzzle-container {
                width: min(78vmin, 320px);
            }
        }

        /* Short viewport: shrink contents to respect padding / prevent overflow */
        @media (max-height: 800px) {
            body {
                padding: 14px;
            }
            .container {
                padding: 22px 36px;
            }
        }
        @media (max-height: 700px) {
            body {
                padding: 12px;
            }
            .container {
                padding: 20px 36px;
            }
        }
        @media (max-height: 600px) {
            .container {
                padding: 16px 36px;
            }
        }
        @media (max-height: 500px) {
            .container {
                padding: 12px 36px;
            }
        }
        @media (max-height: 420px) {
            .container {
                padding: 10px 36px;
            }
        }
        /* Short and narrow: apply stronger scale so content fits */
        @media (max-height: 600px) and (max-width: 480px) {
            .container {
                padding: 12px 36px;
            }
        }
        @media (max-height: 500px) and (max-width: 420px) {
            .container {
                padding: 10px 36px;
            }
        }

        /* Success view: no modal card, content on pink background only */
        .container.container--success {
            background: transparent;
            box-shadow: none;
            padding: 24px;
            position: relative;
            /* Let the final screen fill the viewport width & height */
            width: 100%;
            max-width: none;
            min-height: calc(100vh - 48px);
            max-height: none;
        }

        .container.container--success::before {
            content: '';
            position: fixed;
            inset: 0;
            background: #FFDAE9;
            z-index: -2;
            pointer-events: none;
        }

        /* Success: Yay + gif + Reset */
        .success-yay {
            font-size: 24px;
            font-weight: 600;
            color: #111;
            margin-bottom: 20px;
        }
        
            /* Final success title: appear slightly after the vignette glow */
            .success-final-title {
                opacity: 0;
                transform: translateY(10px);
                transition: opacity 0.6s ease, transform 0.6s ease;
            }
        
            .success-final-title.show {
                opacity: 1;
                transform: translateY(0);
            }


        /* Photo tape background: vertically scrolling columns of photos */
        .photo-tape-bg {
            position: fixed;
            inset: 0;
            background: #FFDAE9;
            overflow: hidden;
            z-index: -3; /* sit fully behind all success content */
            opacity: 0;
            transition: opacity 3s ease;
        }

        .photo-tape-bg.photo-tape-bg--visible {
            opacity: 1;
        }

        /* Fade the photo columns out at the very top and bottom edges */
        .photo-tape-bg::after {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            /* Same pink as the background so images fade into it */
            background: linear-gradient(
                to bottom,
                rgba(255, 218, 233, 1) 0%,
                rgba(255, 218, 233, 0) 18%,
                rgba(255, 218, 233, 0) 82%,
                rgba(255, 218, 233, 1) 100%
            );
            z-index: 1;
        }

        .photo-tape-columns {
            display: flex;
            width: 100%;
            gap: 16px;
            padding: 12px 10px;
            justify-content: space-between;
            height: 100vh;
        }

        .photo-column {
            min-width: 140px;
            flex: 1 1 160px; /* allow columns to grow so the strip is almost as wide as the page */
            overflow: hidden;
            height: 100%;
        }

        .photo-column-track {
            display: flex;
            flex-direction: column;
            gap: 12px;
            animation: scrollPhotosUp 400s linear infinite;
        }

        .photo-column:nth-child(even) .photo-column-track {
            animation: scrollPhotosDown 400s linear infinite;
        }

        .photo-placeholder {
            width: 100%;
            aspect-ratio: 1;
            background: linear-gradient(135deg, #ffb3d9 0%, #ff69b4 100%);
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            opacity: 0.4;
        }

        /* Ensure any real images placed into the tape also follow the same opacity */
        .photo-column img,
        .photo-tape-grid .tape-photo {
            opacity: 0.8;
        }

        @keyframes scrollPhotosUp {
            0% { transform: translateY(0); }
            100% { transform: translateY(-50%); }
        }

        @keyframes scrollPhotosDown {
            0% { transform: translateY(-50%); }
            100% { transform: translateY(0); }
        }

        /* Photo tape foreground: layout of photos in rows/columns */
        .photo-tape-display {
            display: none;
            position: relative;
            z-index: 1;
            background: rgba(255, 218, 233, 0.95);
            padding: 32px;
            border-radius: 12px;
            max-width: 580px;
            margin: 0 auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .photo-tape-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 16px;
        }

        .tape-photo {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #ffb3d9 0%, #ff69b4 100%);
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .reset-btn {
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #c41e3a;
            color: #c41e3a;
            font-size: 28px;
            cursor: pointer;
            padding: 12px 16px;
            margin: 20px auto 0;
            font-family: inherit;
            border-radius: 50%;
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .reset-btn:hover {
            background: #c41e3a;
            color: white;
            transform: rotate(180deg);
        }

        /* Wordsearch styles */
        .wordsearch-container {
            width: min(72vmin, 560px);
            max-width: 100%;
            margin: 12px auto 0;
            height: min(72vmin, 600px);
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background: #fff7fb;
            padding: 14px;
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
        }

        .word-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 6px;
            width: 100%;
            height: 100%;
            grid-auto-rows: 1fr; /* make rows share available height so whole grid fits */
            margin: 0 auto 12px;
        }

        .word-cell {
            background: linear-gradient(180deg, #fff 0%, #f6f0f6 100%);
            border-radius: 6px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: #333;
            user-select: none;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        }

        .word-cell.selected {
            background: linear-gradient(180deg, #ffdbe6 0%, #ffc1dd 100%);
            color: #7a0030;
        }

        .word-cell.found {
            background: linear-gradient(180deg, #dff7e6 0%, #bff0ce 100%);
            color: #05683b;
            cursor: default;
        }

        .word-cell.shared {
            box-shadow: inset 0 -6px 0 rgba(0,0,0,0.04);
            background: linear-gradient(180deg, #b5dac4 0%, #b9e3d1 100%);
            color: #367c3c;
        }

        .word-list {
            display: grid;
            grid-template-columns: repeat(5, auto);
            gap: 12px;
            justify-content: center;
            align-content: center;
            max-width: fit-content;
            margin: 0 auto 8px;
            list-style: none;
            padding: 0;
        }

        .word-list li {
            padding: 6px 10px;
            border-radius: 18px;
            background: #fff;
            font-weight: 600;
            color: #333;
            border: 1px solid rgba(0,0,0,0.04);
        }

        .word-list li.found {
            text-decoration: line-through;
            opacity: 0.45;
        }

        .word-controls { text-align: center; margin-top: 8px; }
        .word-clear-btn { margin-left: 8px; padding: 6px 12px; border-radius: 8px; border: none; background: #ffdbe6; cursor: pointer; }

        /* Wordsearch view: keep all content on a single screen without view-level scrolling */
        #wordsearchView {
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 16px;
        }

        /* Ensure the wordsearch container fills the available space and the grid cells scale to fit */
        .wordsearch-container {
            width: min(72vmin, 560px);
            max-width: 100%;
            margin: 6px auto 0;
            height: min(72vmin, 560px);
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background: #fff7fb;
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
        }

        .word-grid {
            width: 100%;
            height: 100%;
            grid-auto-rows: 1fr;
            margin: 0 auto;
        }

        .word-cell {
            height: auto;
            font-size: clamp(10px, 1.6vmin + 6px, 18px);
        }

        /* Wordle mini-game styles */
        #wordleView {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 8px 16px 16px;
        }

        .wordle-container {
            background: #fff7fb;
            padding: 16px 14px 14px;
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
            width: min(72vmin, 420px);
            max-width: 100%;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
        }

        .wordle-rows {
            display: grid;
            grid-template-rows: repeat(6, 1fr);
            gap: 6px;
        }

        .wordle-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }

        .wordle-cell {
            aspect-ratio: 1;
            border-radius: 6px;
            border: 1px solid #f0cfe2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: clamp(14px, 1.8vmin + 4px, 20px);
            text-transform: uppercase;
            background: #fff;
        }

        .wordle-cell.correct {
            background: #7acb7a;
            color: #fff;
            border-color: #5ca75c;
        }

        .wordle-cell.present {
            background: #ffd46b;
            color: #5c3a00;
            border-color: #e1b652;
        }

        .wordle-cell.absent {
            background: #e7e3ee;
            color: #655e75;
            border-color: #d2cce0;
        }

        .wordle-input-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .wordle-input-row input[type="text"] {
            flex: 1;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #d9c5e6;
            font-size: 14px;
            text-transform: uppercase;
        }

        .wordle-input-row button {
            padding: 8px 14px;
            border-radius: 999px;
            border: none;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
        }

        .wordle-input-row button:disabled {
            opacity: 0.6;
            cursor: default;
        }

        .wordle-message {
            font-size: 13px;
            color: #7b5471;
            min-height: 1.2em;
        }

        /* Sudoku mini-game styles */
        #sudokuView {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 8px 16px 16px;
        }

        .sudoku-container {
            width: min(80vmin, 460px);
            max-width: 100%;
            background: #fff7fb;
            padding: 14px;
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px;
            background: #edd6e7;
            padding: 2px;
            border-radius: 8px;
        }

        .sudoku-cell {
            aspect-ratio: 1;
            border: 1px solid #f0cfe2;
            background: #fff;
            font-size: clamp(12px, 1.8vmin + 4px, 18px);
            font-weight: 600;
            color: #3b2c3a;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease, color 0.6s ease, text-shadow 0.6s ease, opacity 0.6s ease;
        }

        .sudoku-cell.revealed {
            background: transparent;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.6);
            opacity: 1;
            background-repeat: no-repeat;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.45);
        }

        .sudoku-cell.reveal-in {
            opacity: 0;
            animation: sudokuReveal 0.6s ease forwards;
        }

        .sudoku-cell.fixed {
            background: #f1e9f3;
            color: #6a5266;
            cursor: default;
        }

        .sudoku-cell.fixed.revealed {
            background: transparent;
            color: #fff;
        }

        .sudoku-cell.active {
            background: #ffe7f1;
            box-shadow: inset 0 0 0 2px #f5576c;
        }


        .sudoku-keypad {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .sudoku-key {
            padding: 8px 0;
            border-radius: 999px;
            border: none;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .sudoku-key.clear {
            background: #e8deea;
            color: #6a5266;
        }

        .sudoku-message {
            font-size: 13px;
            color: #7b5471;
            min-height: 1.2em;
            text-align: center;
        }

        .sudoku-grid .sudoku-cell:nth-child(3n) {
            border-right: 2px solid #d1b2c7;
        }

        .sudoku-grid .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-grid .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid #d1b2c7;
        }

        .sudoku-grid.complete {
            gap: 0;
            padding: 0;
            background: transparent;
        }

        .sudoku-grid.complete .sudoku-cell {
            border: 0;
            box-shadow: none;
            border-radius: 0;
            color: transparent;
            text-shadow: none;
        }

        .sudoku-grid.complete .sudoku-cell.revealed {
            box-shadow: none;
        }

        .sudoku-grid.complete .sudoku-cell:nth-child(3n) {
            border-right: 0;
        }

        .sudoku-grid.complete .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-grid.complete .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 0;
        }

        @keyframes sudokuReveal {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Minesweeper mini-game styles */
        #minesweeperView {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 8px 16px 16px;
        }

        .minesweeper-container {
            width: min(80vmin, 420px);
            max-width: 100%;
            background: #fff7fb;
            padding: 14px;
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .minesweeper-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            width: 100%;
        }

        .minesweeper-cell {
            aspect-ratio: 1;
            border-radius: 8px;
            border: 1px solid #f0cfe2;
            background: #fff;
            font-weight: 600;
            font-size: clamp(12px, 1.6vmin + 4px, 18px);
            color: #3b2c3a;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        }

        .minesweeper-cell.revealed {
            background: #f4eaf4;
            cursor: default;
        }

        .minesweeper-cell.mine {
            background: #ffd7d7;
            color: #b23a3a;
        }

        .minesweeper-cell.flagged {
            background: #ffe7f1;
            color: #c41e3a;
        }

        .minesweeper-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .minesweeper-button {
            padding: 8px 14px;
            border-radius: 999px;
            border: none;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: #fff;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .minesweeper-button.secondary {
            background: #e8deea;
            color: #6a5266;
        }

        .minesweeper-message {
            font-size: 13px;
            color: #7b5471;
            min-height: 1.2em;
            text-align: center;
        }

        /* Smooth bloom-in for the final success view instead of a page turn */
        #successView {
            transform-origin: center center;
        }

        #successView.success-fade-in {
            animation: successBloomIn 1.05s cubic-bezier(0.16, 0.84, 0.24, 1) forwards;
        }

        /* Progress bar */
        .progress-shell {
            position: fixed;
            top: 18px;
            left: 50%;
            transform: translate3d(-50%, 0, 0);
            width: min(520px, calc(100vw - 32px));
            z-index: 12;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .progress-shell.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translate3d(-50%, -60px, 0);
        }

        body.show-modal .progress-shell {
            opacity: 1;
            pointer-events: auto;
        }

        .progress-track {
            position: relative;
            height: 10px;
            background: #f3dbe8;
            border-radius: 999px;
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.06);
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 999px;
            transition: width 0.4s ease;
        }

        .progress-steps {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            margin-top: 6px;
            font-size: 11px;
            color: #7b5471;
            font-weight: 600;
        }

        .progress-step {
            text-align: center;
        }

        .progress-step.active {
            color: #c41e3a;
        }

        .progress-steps.message {
            grid-template-columns: 1fr;
            text-align: center;
            font-size: 12px;
            color: #c41e3a;
        }

    </style>
</head>
<body>
    <!-- ENVELOPE: no modal, just envelope on pink background -->
    <div id="envelopeStage">
        <div class="envelope" id="envelope">
            <div class="envelope-heart" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path fill-rule="evenodd" d="M11.645 20.91l-.007-.003-.022-.012a15.247 15.247 0 01-.383-.218 25.18 25.18 0 01-4.244-3.17C4.688 15.36 2.25 12.174 2.25 8.25 2.25 5.322 4.714 3 7.688 3A5.5 5.5 0 0112 5.052 5.5 5.5 0 0116.313 3c2.973 0 5.437 2.322 5.437 5.25 0 3.925-2.438 7.111-4.739 9.256a25.175 25.175 0 01-4.244 3.17 15.247 15.247 0 01-.383.219l-.022.012-.007.004-.003.001a.752.752 0 01-.704 0l-.003-.001z" clip-rule="evenodd" /></svg>
            </div>
            <div class="envelope-flap">
                <svg class="envelope-flap-outline" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
                    <line x1="0" y1="0" x2="50" y2="50" stroke="#d4c4a8" stroke-width="3" vector-effect="non-scaling-stroke" />
                    <line x1="50" y1="50" x2="100" y2="0" stroke="#d4c4a8" stroke-width="3" vector-effect="non-scaling-stroke" />
                </svg>
            </div>
        </div>
    </div>

    <div class="success-vignette" id="successVignette"></div>

    <div class="progress-shell" aria-label="Puzzle progress">
        <div class="progress-track">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-steps" id="progressSteps">
            <span class="progress-step" data-step="0">Puzzle</span>
            <span class="progress-step" data-step="1">Wordsearch</span>
            <span class="progress-step" data-step="2">Wordle</span>
            <span class="progress-step" data-step="3">Sudoku</span>
            <span class="progress-step" data-step="4">Minesweeper</span>
        </div>
    </div>

    <div class="container">
        <div class="modal-inner">
            <!-- VIEW: Puzzle (playing + completed state in same view) -->
            <div id="puzzleView" class="modal-view">
                <h1 class="modal-title">Made for the love of my life <3</h1>
                <div class="puzzle-container" id="puzzleContainer">
                    <div class="puzzle-grid-wrap" id="puzzleGridWrap">
                        <div class="puzzle-grid" id="puzzleGrid"></div>
                        <div class="puzzle-full-image-overlay" id="puzzleFullImageOverlay">
                            <img src="images/full-image.png" alt="" />
                        </div>
                    </div>
                </div>
                <div class="puzzle-reveal-text" id="puzzleRevealText">
                    <p class="complete-line">...you complete me.</p>
                </div>
            </div>
            <!-- WORDSEARCH VIEW: shown after first puzzle -->
            <div id="wordsearchView" class="modal-view">
                <p style="margin-bottom:8px;">Find these words that make me think of you:</p>
                <ul class="word-list" id="wordList">
                    <li data-word="LOVELY">Lovely</li>
                    <li data-word="BEAUTIFUL">Beautiful</li>
                    <li data-word="GORGEOUS">Gorgeous</li>
                    <li data-word="AMAZING">Amazing</li>
                    <li data-word="VALENTINE">Valentine</li>
                    <li data-word="PRETTY">Pretty</li>
                    <li data-word="SWEET">Sweet</li>
                    <li data-word="CUTE">Cute</li>
                    <li data-word="MINE">Mine</li>
                    <li data-word="KIND">Kind</li>
                </ul>

                <div class="wordsearch-container">
                    <div class="word-grid" id="wordGrid" aria-hidden="false"></div>
                    <div class="word-controls">
                        <span id="currentSelection">Selected: </span>
                        <button id="clearSelectionBtn" class="word-clear-btn">Clear</button>
                    </div>
                </div>
            </div>

            <!-- WORDLE VIEW: appears after completing the wordsearch -->
            <div id="wordleView" class="modal-view">
                <p style="font-size: 14px; color: #555; margin-bottom: 6px; text-align: center; max-width: 420px;">Guess the 5-letter word for how I feel about you.</p>
                <div class="wordle-container">
                    <div class="wordle-rows" id="wordleRows"></div>
                    <div class="wordle-input-row">
                        <input type="text" id="wordleInput" maxlength="5" autocomplete="off" placeholder="Type a 5-letter word" />
                        <button type="button" id="wordleGuessBtn">Guess</button>
                    </div>
                    <div class="wordle-message" id="wordleMessage"></div>
                </div>
            </div>

            <!-- SUDOKU VIEW: appears after Wordle, before the question -->
            <div id="sudokuView" class="modal-view">
                
                <p style="font-size: 14px; color: #555; margin-bottom: 6px; text-align: center; max-width: 420px;">Fill the grid to unlock a memory.</p>
                <div class="sudoku-container">
                    <div class="sudoku-grid" id="sudokuGrid" aria-label="Sudoku grid" role="grid"></div>
                    <div class="sudoku-keypad" id="sudokuKeypad" aria-label="Sudoku keypad"></div>
                    <div class="sudoku-message" id="sudokuMessage"></div>
                </div>
            </div>

            <!-- MINESWEEPER VIEW: appears after Sudoku, before the question -->
            <div id="minesweeperView" class="modal-view">
                <p class="modal-title" style="margin-bottom: 8px;">U Da Bomb üí£</p>
                <p style="font-size: 14px; color: #555; margin-bottom: 6px; text-align: center; max-width: 420px;">Clear the board without hitting a mine.</p>
                <div class="minesweeper-container">
                    <div class="minesweeper-grid" id="minesweeperGrid" aria-label="Minesweeper grid" role="grid"></div>
                    <div class="minesweeper-controls">
                        <button type="button" class="minesweeper-button secondary" id="minesweeperFlagBtn">Flag Mode: Off</button>
                        <button type="button" class="minesweeper-button secondary" id="minesweeperResetBtn">Reset</button>
                    </div>
                    <div class="minesweeper-message" id="minesweeperMessage"></div>
                </div>
            </div>

            <!-- QUESTION VIEW: appears after completing the wordsearch; hides the wordsearch when shown -->
            <div id="questionView" class="modal-view">
                <p class="modal-title">Will you be my Valentine my love?</p>
                <div class="question-buttons">
                    <button type="button" class="yes-only-btn" id="yesBtn">Yes</button>
                    <button type="button" class="no-run-btn" id="noBtn">No</button>
                </div>
                <div class="question-emoji" id="pleadEmoji" aria-hidden="true">üôèüèª</div>
            </div>
            </div>

            <!-- VIEW: Success -->
            <div id="successView" class="modal-view">
                <div class="photo-tape-bg">
                    <div class="photo-tape-columns">
                        <div class="photo-column">
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                        </div>
                        <div class="photo-column">
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                        </div>
                        <div class="photo-column">
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                        </div>
                        <div class="photo-column">
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                        </div>
                        <div class="photo-column">
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                        </div>
                        <div class="photo-column">
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                            <div class="photo-placeholder"></div>
                        </div>
                    </div>
                </div>
                <p class="modal-title success-final-title" style="position: relative; z-index: 2;">Yay, I can't wait to <br>see you baby <3</p>
                <div class="photo-tape-display">
                    <div class="photo-tape-grid">
                        <div class="tape-photo"></div>
                        <div class="tape-photo"></div>
                        <div class="tape-photo"></div>
                        <div class="tape-photo"></div>
                        <div class="tape-photo"></div>
                        <div class="tape-photo"></div>
                        <div class="tape-photo"></div>
                        <div class="tape-photo"></div>
                        <div class="tape-photo"></div>
                    </div>
                </div>
                <button type="button" class="reset-btn success-final-title" id="resetBtn" style="position: relative; z-index: 2;">‚Üª</button>
            </div>
        </div>
    </div>

    <script>
        // ENVELOPE ‚Üí MODAL (one modal, two views: puzzle + success)
        const envelopeStage = document.getElementById('envelopeStage');
        const envelope = document.getElementById('envelope');
        const puzzleGrid = document.getElementById('puzzleGrid');
        const puzzleView = document.getElementById('puzzleView');
        const successView = document.getElementById('successView');
        const questionView = document.getElementById('questionView');
        const wordleView = document.getElementById('wordleView');
        const sudokuView = document.getElementById('sudokuView');
        const minesweeperView = document.getElementById('minesweeperView');
        const wordleRowsEl = document.getElementById('wordleRows');
        const wordleInput = document.getElementById('wordleInput');
        const wordleGuessBtn = document.getElementById('wordleGuessBtn');
        const wordleMessage = document.getElementById('wordleMessage');
        const sudokuGridEl = document.getElementById('sudokuGrid');
        const sudokuKeypadEl = document.getElementById('sudokuKeypad');
        const sudokuMessageEl = document.getElementById('sudokuMessage');
        const minesweeperGridEl = document.getElementById('minesweeperGrid');
        const minesweeperMessageEl = document.getElementById('minesweeperMessage');
        const minesweeperFlagBtn = document.getElementById('minesweeperFlagBtn');
        const minesweeperResetBtn = document.getElementById('minesweeperResetBtn');
        const progressShell = document.querySelector('.progress-shell');
        const progressFill = document.getElementById('progressFill');
        const progressSteps = document.getElementById('progressSteps');
        const container = document.querySelector('.container');

        const WORDLE_TARGET = 'CRAZY'; // Set the 5-letter Wordle word here
        const WORDLE_MAX_GUESSES = 6;
        let wordleAttempts = [];
        let wordleSolved = false;
        let wordleExtraChanceUsed = false;
        const wordleTarget = sanitizeWordleTarget(WORDLE_TARGET);

        const SUDOKU_PUZZLE = [
            [0, 0, 0, 2, 6, 0, 7, 0, 1],
            [6, 8, 0, 0, 7, 0, 0, 9, 0],
            [1, 9, 0, 0, 0, 4, 5, 0, 0],
            [8, 2, 0, 1, 0, 0, 0, 4, 0],
            [0, 0, 4, 6, 0, 2, 9, 0, 0],
            [0, 5, 0, 0, 0, 3, 0, 2, 8],
            [0, 0, 9, 3, 0, 0, 0, 7, 4],
            [0, 4, 0, 0, 5, 0, 0, 3, 6],
            [7, 0, 3, 0, 1, 8, 0, 0, 0]
        ];
        const SUDOKU_SOLUTION = [
            [4, 3, 5, 2, 6, 9, 7, 8, 1],
            [6, 8, 2, 5, 7, 1, 4, 9, 3],
            [1, 9, 7, 8, 3, 4, 5, 6, 2],
            [8, 2, 6, 1, 9, 5, 3, 4, 7],
            [3, 7, 4, 6, 8, 2, 9, 1, 5],
            [9, 5, 1, 7, 4, 3, 6, 2, 8],
            [5, 1, 9, 3, 2, 6, 8, 7, 4],
            [2, 4, 8, 9, 5, 7, 1, 3, 6],
            [7, 6, 3, 4, 1, 8, 2, 5, 9]
        ];
        let sudokuState = [];
        let sudokuActive = null;
        let sudokuRevealedBlocks = new Set();

        const MINESWEEPER_ROWS = 8;
        const MINESWEEPER_COLS = 8;
        const MINESWEEPER_MINES = 10;
        let minesweeperCells = [];
        let minesweeperFlagMode = false;
        let minesweeperGameOver = false;
        let minesweeperRevealedCount = 0;

        const PUZZLE_ORDER = ['puzzleView', 'wordsearchView', 'wordleView', 'sudokuView', 'minesweeperView'];
        
        /**
         * Switch from one modal view to another with a page-turn animation.
         * If `fromEl` is null, the `toEl` will simply animate in.
         * `forward` controls the turn direction (true -> left-origin forward turn).
         */
        function switchView(fromEl, toEl, forward = true) {
            if (!toEl) return;
            const duration = 750; // ms, should match CSS

            updateProgressForView(toEl.id);

            const origin = forward ? 'left center' : 'right center';
            if (fromEl) {
                fromEl.style.transformOrigin = origin;
                fromEl.classList.add('turn-out');
            }

            toEl.style.transformOrigin = origin;
            toEl.classList.add('turn-in');
            toEl.classList.add('visible');

            // cleanup after animation completes
            setTimeout(() => {
                if (fromEl) {
                    fromEl.classList.remove('visible', 'turn-out');
                    fromEl.style.transformOrigin = '';
                }
                toEl.classList.remove('turn-in');
                toEl.style.transformOrigin = '';
            }, duration + 30);
        }

        function updateProgressForView(viewId) {
            const index = PUZZLE_ORDER.indexOf(viewId);
            if (index === -1 || !progressFill || !progressSteps) return;
            const percent = ((index + 1) / PUZZLE_ORDER.length) * 100;
            progressFill.style.width = `${percent}%`;
            Array.from(progressSteps.children).forEach((step, stepIndex) => {
                if (stepIndex <= index) step.classList.add('active');
                else step.classList.remove('active');
            });
        }
        
        envelope.addEventListener('click', () => {
            envelope.style.pointerEvents = 'none';
            const heart = envelope.querySelector('.envelope-heart');
            heart.classList.add('hidden');
            setTimeout(() => {
                envelope.classList.add('opening');
                setTimeout(() => {
                    envelopeStage.classList.add('envelope-stage-fade-out');
                    setTimeout(() => {
                        envelopeStage.style.display = 'none';
                        document.body.classList.add('show-modal');
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => switchView(null, puzzleView, true));
                        });
                    }, 450);
                }, 700);
            }, 380);
        });

        
        let tiles = [];
        
        // 3x3 puzzle: pieces 1‚Äì9, empty piece is 3 (top-right).
        const EMPTY_PIECE = 3;
        const solution = [1, 2, 3, 4, 5, 6, 7, 8, 9]; // empty (3) at index 2 = top-right
        let currentState = [...solution];
        
        function initPuzzle() {
            scramblePuzzle();
            renderPuzzle();
        }
        
        function scramblePuzzle() {
            // Perform 25 random moves to ensure puzzle is hard (typically requires 7+ moves to solve)
            for (let i = 0; i < 40; i++) {
                const emptyIndex = currentState.indexOf(EMPTY_PIECE);
                const validMoves = getValidMoves(emptyIndex);
                const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                [currentState[emptyIndex], currentState[randomMove]] = [currentState[randomMove], currentState[emptyIndex]];
            }
        }
        
        function getValidMoves(emptyIndex) {
            const validMoves = [];
            const row = Math.floor(emptyIndex / 3);
            const col = emptyIndex % 3;
            
            if (row > 0) validMoves.push(emptyIndex - 3);
            if (row < 2) validMoves.push(emptyIndex + 3);
            if (col > 0) validMoves.push(emptyIndex - 1);
            if (col < 2) validMoves.push(emptyIndex + 1);
            
            return validMoves;
        }
        
        function renderPuzzle() {
            puzzleGrid.innerHTML = '';
            tiles = [];
            
            currentState.forEach((piece, index) => {
                const tile = document.createElement('div');
                tile.className = 'puzzle-tile';
                
                if (piece === EMPTY_PIECE) {
                    tile.classList.add('empty');
                    // No image: empty space is transparent until puzzle is solved
                } else {
                    tile.style.backgroundImage = `url('images/tile-${piece}.png')`;
                    tile.onclick = () => moveTile(index);
                }
                
                puzzleGrid.appendChild(tile);
                tiles.push(tile);
            });
        }
        
        function moveTile(index) {
            const emptyIndex = currentState.indexOf(EMPTY_PIECE);
            const validMoves = getValidMoves(emptyIndex);
            
            if (validMoves.includes(index)) {
                [currentState[emptyIndex], currentState[index]] = [currentState[index], currentState[emptyIndex]];
                renderPuzzle();
                
                // Check if solved
                if (isPuzzleSolved()) {
                    setTimeout(onPuzzleSolved, 300);
                }
            }
        }
        
        function isPuzzleSolved() {
            return currentState.every((tile, index) => tile === solution[index]);
        }
        
        function onPuzzleSolved() {
            const puzzleContainer = document.getElementById('puzzleContainer');
            const puzzleGridWrap = document.getElementById('puzzleGridWrap');
            const puzzleRevealText = document.getElementById('puzzleRevealText');
            const puzzleFullImageOverlay = document.getElementById('puzzleFullImageOverlay');
            const emptyTile = puzzleGrid.querySelector('.puzzle-tile.empty');
            if (emptyTile) emptyTile.style.backgroundImage = "url('images/tile-3.png')";
            puzzleContainer.classList.add('completed');
            puzzleGrid.classList.add('merging');
            runStreamersFor(2000);
            setTimeout(() => {
                puzzleFullImageOverlay.classList.add('show');
                setTimeout(() => {
                    puzzleGridWrap.classList.add('revealing');
                    // Pause to admire the photo longer before proceeding to the wordsearch view
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            const wordsearchView = document.getElementById('wordsearchView');
                            switchView(puzzleView, wordsearchView, true);
                            initWordsearch();
                        });
                    });
                }, 3000);
            }, 280);
        }
        
        function createSparkles(x, y) {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    sparkle.style.left = x + (Math.random() - 0.5) * 50 + 'px';
                    sparkle.style.top = y + (Math.random() - 0.5) * 50 + 'px';
                    sparkle.style.background = ['#f093fb', '#f5576c', '#ffd700'][Math.floor(Math.random() * 3)];
                    document.body.appendChild(sparkle);
                    setTimeout(() => sparkle.remove(), 1000);
                }, i * 50);
            }
        }
        
        initPuzzle();
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            window.location.reload();
        });

        // Photo loading from memories folder
        async function loadPhotosFromManifest() {
            try {
                const response = await fetch('images/memories/manifest.json');
                const data = await response.json();
                return data.photos || [];
            } catch (error) {
                console.warn('Could not load photos manifest:', error);
                return [];
            }
        }

        function getRandomPhoto(photos) {
            if (photos.length === 0) return null;
            return photos[Math.floor(Math.random() * photos.length)];
        }

        function getRandomPhotoExcluding(photos, exclude) {
            if (photos.length === 0) return null;
            if (photos.length === 1) return photos[0];

            let candidate = exclude;
            while (candidate === exclude) {
                candidate = getRandomPhoto(photos);
            }
            return candidate;
        }

        function initPhotoTapeColumns() {
            const columns = document.querySelectorAll('.photo-tape-bg .photo-column');
            columns.forEach(column => {
                let track = column.querySelector('.photo-column-track');
                if (track) return;

                track = document.createElement('div');
                track.className = 'photo-column-track';
                const originals = Array.from(column.children);
                originals.forEach(child => {
                    child.dataset.photoOriginal = 'true';
                    track.appendChild(child);
                });
                column.appendChild(track);
            });
        }

        function rebuildPhotoTapeClones() {
            const columns = document.querySelectorAll('.photo-tape-bg .photo-column');
            columns.forEach(column => {
                const track = column.querySelector('.photo-column-track');
                if (!track) return;

                track.querySelectorAll('[data-photo-clone="true"]').forEach(clone => clone.remove());
                const originals = Array.from(track.querySelectorAll('[data-photo-original="true"]'));
                originals.forEach(original => {
                    const clone = original.cloneNode(true);
                    clone.dataset.photoClone = 'true';
                    clone.removeAttribute('data-photo-original');
                    track.appendChild(clone);
                });
            });
        }

        async function populatePhotoTape() {
            const photos = await loadPhotosFromManifest();

            initPhotoTapeColumns();
            rebuildPhotoTapeClones();

            if (photos.length === 0) return; // Use placeholders if no photos

            // Populate background tape columns (no duplicates in a row)
            const columns = document.querySelectorAll('.photo-tape-bg .photo-column');
            columns.forEach(column => {
                const originals = column.querySelectorAll('.photo-column-track [data-photo-original="true"]');
                let lastPhoto = null;

                originals.forEach(placeholder => {
                    const photo = getRandomPhotoExcluding(photos, lastPhoto);
                    if (photo) {
                        placeholder.style.backgroundImage = `url('images/memories/Photos/${photo}')`;
                        placeholder.style.backgroundSize = 'cover';
                        placeholder.style.backgroundPosition = 'center';
                        lastPhoto = photo;
                    }
                });
            });

            rebuildPhotoTapeClones();

            // Populate foreground tape grid
            const fgPhotos = document.querySelectorAll('.tape-photo');
            fgPhotos.forEach(photo => {
                const img = getRandomPhoto(photos);
                if (img) {
                    photo.style.backgroundImage = `url('images/memories/Photos/${img}')`;
                    photo.style.backgroundSize = 'cover';
                    photo.style.backgroundPosition = 'center';
                }
            });
        }

        // Call this when success view appears
        const originalSuccessViewHTML = successView.innerHTML;
        const observer = new MutationObserver(() => {
            if (successView.classList.contains('visible')) {
                populatePhotoTape();
                if (progressShell) progressShell.classList.add('hidden');
                observer.disconnect();
            }
        });
        observer.observe(successView, { attributes: true, attributeFilter: ['class'] });

        // Fallback: also populate on init in case success view is shown via skip
        populatePhotoTape();

        // Attach yes button handler (works for both normal and skip flow)
        document.getElementById('yesBtn').addEventListener('click', () => {
            // Delay the heart/emoji confetti so it starts a bit after
            // the final vignette / box-shadow animation begins.
            setTimeout(() => {
                runConfettiFor(20000, 4);
            }, 1400);
            // Switch the container into full-screen success mode
            container.classList.add('container--success');

            // Fade out the question view using its built-in opacity transition
            if (questionView) {
                questionView.classList.remove('visible', 'turn-in', 'turn-out');
            }

            // Fade in the success view with a smooth scale/opacity animation
            if (successView) {
                successView.classList.remove('turn-in', 'turn-out');
                successView.classList.add('visible', 'success-fade-in');
            }

            // Show the vignette overlay on top of everything
            const vignette = document.getElementById('successVignette');
            if (vignette) vignette.classList.add('show');

            // Gently fade in the scrolling photo columns after the vignette begins
            const tapeBg = successView ? successView.querySelector('.photo-tape-bg') : null;
            if (tapeBg) {
                // Small delay so the background appears under the already-growing pink vignette
                setTimeout(() => {
                    tapeBg.classList.add('photo-tape-bg--visible');
                }, 250);
            }

            // Delay the final "I can't wait..." text and reset button
            // until after the vignette has bloomed
            const finalEls = successView ? successView.querySelectorAll('.success-final-title') : null;
            if (finalEls && finalEls.length) {
                finalEls.forEach(el => el.classList.remove('show'));
                setTimeout(() => {
                    finalEls.forEach(el => el.classList.add('show'));
                }, 450);
            }

            if (progressShell) {
                progressShell.classList.add('hidden');
            }
        });

        // Make the "No" button run away when the cursor gets close
        (function setupNoButtonRunAway() {
            const noBtn = document.getElementById('noBtn');
            const yesBtn = document.getElementById('yesBtn');
            const area = document.querySelector('#questionView .question-buttons');
            const emoji = document.getElementById('pleadEmoji');
            if (!noBtn || !area) return;

            const THRESHOLD = 140; // desired minimum distance (px) from cursor to button center
            let emojiLockedOn = false; // once true, emoji stays visible
            let yesScale = 0.95; // Yes button starts just under normal size

            function moveNoButtonAway(mouseX, mouseY) {
                const areaRect = area.getBoundingClientRect();
                const btnRect = noBtn.getBoundingClientRect();
                const maxX = Math.max(0, areaRect.width - btnRect.width);
                const maxY = Math.max(0, areaRect.height - btnRect.height);

                let bestLeft = noBtn.offsetLeft;
                let bestTop = noBtn.offsetTop;
                let bestDist = 0;

                // Try a bunch of random positions and keep the farthest from the mouse
                for (let i = 0; i < 30; i++) {
                    const candLeft = Math.random() * maxX;
                    const candTop = Math.random() * maxY;

                    const cx = areaRect.left + candLeft + btnRect.width / 2;
                    const cy = areaRect.top + candTop + btnRect.height / 2;
                    const dx = mouseX - cx;
                    const dy = mouseY - cy;
                    const dist = Math.hypot(dx, dy);

                    if (dist > bestDist) {
                        bestDist = dist;
                        bestLeft = candLeft;
                        bestTop = candTop;
                    }
                }

                noBtn.style.left = bestLeft + 'px';
                noBtn.style.top = bestTop + 'px';

                // Each time No escapes, make Yes a bit bigger (up to a cap)
                if (yesBtn) {
                    // Smaller increments but a larger possible final size
                    yesScale = Math.min(6, yesScale + 0.035);
                    yesBtn.style.transform = 'scale(' + yesScale.toFixed(2) + ')';
                }
            }

            // Initialize the button in a starting spot (right of Yes)
            requestAnimationFrame(() => {
                const areaRect = area.getBoundingClientRect();
                const btnRect = noBtn.getBoundingClientRect();
                const startLeft = Math.min(areaRect.width - btnRect.width, areaRect.width * 0.6);
                const startTop = Math.max(0, (areaRect.height - btnRect.height) / 2);
                noBtn.style.left = startLeft + 'px';
                noBtn.style.top = startTop + 'px';
            });

            area.addEventListener('mousemove', (e) => {
                const btnRect = noBtn.getBoundingClientRect();
                const cx = btnRect.left + btnRect.width / 2;
                const cy = btnRect.top + btnRect.height / 2;
                const dx = e.clientX - cx;
                const dy = e.clientY - cy;
                const dist = Math.hypot(dx, dy);

                if (dist < THRESHOLD) {
                    moveNoButtonAway(e.clientX, e.clientY);
                    if (emoji && !emojiLockedOn) {
                        emojiLockedOn = true;
                        emoji.classList.add('show');
                    }
                }
            });
        })();

        // --- Wordle logic ---
        let wordleDictionary = null;
        let wordleDictionaryPromise = null;

        function loadWordleDictionary() {
            if (wordleDictionaryPromise) return wordleDictionaryPromise;
            wordleDictionaryPromise = fetch('wordle-word-list/5-letter-words.txt')
                .then((response) => {
                    if (!response.ok) throw new Error('Failed to load word list');
                    return response.text();
                })
                .then((text) => {
                    const set = new Set();
                    text.split(/\r?\n/).forEach((line) => {
                        const word = line.trim();
                        if (word.length === 5 && /^[a-zA-Z]+$/.test(word)) {
                            set.add(word.toUpperCase());
                        }
                    });
                    set.add(wordleTarget);
                    wordleDictionary = set;
                    return set;
                })
                .catch((error) => {
                    console.warn('Word list unavailable:', error);
                    wordleDictionary = new Set([wordleTarget]);
                    return wordleDictionary;
                });
            return wordleDictionaryPromise;
        }

        function sanitizeWordleTarget(word) {
            const cleaned = String(word || '').toUpperCase().replace(/[^A-Z]/g, '');
            if (cleaned.length === 5) return cleaned;
            return 'SWEET';
        }

        function initWordle() {
            loadWordleDictionary();
            wordleAttempts = [];
            wordleSolved = false;
            wordleExtraChanceUsed = false;
            if (wordleInput) {
                wordleInput.value = '';
                wordleInput.disabled = false;
            }
            if (wordleGuessBtn) wordleGuessBtn.disabled = false;
            if (wordleMessage) wordleMessage.textContent = '';
            renderWordleRows();
        }

        function renderWordleRows() {
            if (!wordleRowsEl) return;
            wordleRowsEl.innerHTML = '';
            const totalRows = WORDLE_MAX_GUESSES + (wordleExtraChanceUsed ? 1 : 0);
            for (let r = 0; r < totalRows; r++) {
                const rowEl = document.createElement('div');
                rowEl.className = 'wordle-row';
                const attempt = wordleAttempts[r] || null;
                for (let c = 0; c < 5; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'wordle-cell';
                    if (attempt) {
                        cell.textContent = attempt.guess[c] || '';
                        if (attempt.result[c]) cell.classList.add(attempt.result[c]);
                    }
                    rowEl.appendChild(cell);
                }
                wordleRowsEl.appendChild(rowEl);
            }
        }

        function scoreWordleGuess(guess, target) {
            const result = Array(5).fill('absent');
            const counts = {};
            for (let i = 0; i < 5; i++) {
                const ch = target[i];
                counts[ch] = (counts[ch] || 0) + 1;
            }

            for (let i = 0; i < 5; i++) {
                if (guess[i] === target[i]) {
                    result[i] = 'correct';
                    counts[guess[i]] -= 1;
                }
            }

            for (let i = 0; i < 5; i++) {
                if (result[i] === 'correct') continue;
                const ch = guess[i];
                if (counts[ch] > 0) {
                    result[i] = 'present';
                    counts[ch] -= 1;
                }
            }

            return result;
        }

        async function handleWordleGuess() {
            if (wordleSolved) return;
            const rawGuess = wordleInput ? wordleInput.value : '';
            const guess = String(rawGuess || '').toUpperCase().replace(/[^A-Z]/g, '');

            if (guess.length !== 5) {
                if (wordleMessage) wordleMessage.textContent = 'Please enter a 5-letter word.';
                return;
            }

            if (!wordleDictionary) {
                if (wordleMessage) wordleMessage.textContent = 'Loading word list...';
                try {
                    await loadWordleDictionary();
                } catch (error) {
                    // loadWordleDictionary already falls back; ignore.
                }
            }

            if (!wordleDictionary) {
                if (wordleMessage) wordleMessage.textContent = 'Word list is unavailable. Try again.';
                return;
            }

            if (!wordleDictionary.has(guess)) {
                if (wordleMessage) wordleMessage.textContent = 'That is not a valid word.';
                return;
            }

            const maxAllowed = WORDLE_MAX_GUESSES + (wordleExtraChanceUsed ? 1 : 0);
            if (wordleAttempts.length >= maxAllowed) return;

            const result = scoreWordleGuess(guess, wordleTarget);
            wordleAttempts.push({ guess, result });
            renderWordleRows();

            if (guess === wordleTarget) {
                wordleSolved = true;
                if (wordleMessage) wordleMessage.textContent = 'You got it! üíï';
                if (wordleInput) wordleInput.disabled = true;
                if (wordleGuessBtn) wordleGuessBtn.disabled = true;
                runStreamersFor(2000);
                setTimeout(() => {
                    if (wordleView && sudokuView) {
                        switchView(wordleView, sudokuView, true);
                        initSudoku();
                    }
                }, 800);
                return;
            }

            if (wordleMessage) {
                const guessesLeft = maxAllowed - wordleAttempts.length;
                wordleMessage.textContent = `${guessesLeft} guesses left.`;
            }

            if (wordleInput) wordleInput.value = '';

            if (wordleAttempts.length >= WORDLE_MAX_GUESSES && !wordleExtraChanceUsed) {
                wordleExtraChanceUsed = true;
                if (wordleMessage) wordleMessage.textContent = 'Extra chance cause I love you. 1 guess left.';
                renderWordleRows();
                return;
            }

            if (wordleAttempts.length >= maxAllowed) {
                if (wordleMessage) wordleMessage.textContent = `Out of guesses. The word was ${wordleTarget}.`;
                if (wordleInput) wordleInput.disabled = true;
                if (wordleGuessBtn) wordleGuessBtn.disabled = true;
                setTimeout(() => {
                    if (wordleView && sudokuView) {
                        switchView(wordleView, sudokuView, true);
                        initSudoku();
                    }
                }, 1200);
            }
        }

        if (wordleGuessBtn) wordleGuessBtn.addEventListener('click', handleWordleGuess);
        if (wordleInput) {
            wordleInput.addEventListener('input', () => {
                wordleInput.value = wordleInput.value.replace(/[^a-zA-Z]/g, '').toUpperCase();
            });
            wordleInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    handleWordleGuess();
                }
            });
        }

        // --- Sudoku logic ---
        let sudokuGridBound = false;
        let sudokuKeypadBound = false;
        let sudokuKeyboardBound = false;

        function initSudoku() {
            sudokuState = SUDOKU_PUZZLE.map(row => row.slice());
            sudokuActive = null;
            sudokuRevealedBlocks = new Set();
            if (sudokuMessageEl) sudokuMessageEl.textContent = '';
            renderSudoku();
            renderSudokuKeypad();

            if (sudokuGridEl && !sudokuGridBound) {
                sudokuGridEl.addEventListener('click', (event) => {
                    const cell = event.target.closest('.sudoku-cell');
                    if (!cell || cell.classList.contains('fixed')) return;
                    const r = Number(cell.dataset.r);
                    const c = Number(cell.dataset.c);
                    sudokuActive = { r, c };
                    renderSudoku();
                });
                sudokuGridBound = true;
            }

            if (sudokuKeypadEl && !sudokuKeypadBound) {
                sudokuKeypadEl.addEventListener('click', (event) => {
                    const btn = event.target.closest('button');
                    if (!btn) return;
                    if (btn.dataset.action === 'clear') {
                        updateSudokuCell(0);
                        return;
                    }
                    const value = Number(btn.dataset.value || 0);
                    if (value >= 1 && value <= 9) updateSudokuCell(value);
                });
                sudokuKeypadBound = true;
            }

            if (!sudokuKeyboardBound) {
                document.addEventListener('keydown', (event) => {
                    if (!sudokuView || !sudokuView.classList.contains('visible')) return;
                    const activeTag = document.activeElement ? document.activeElement.tagName : '';
                    if (activeTag === 'INPUT' || activeTag === 'TEXTAREA') return;
                    if (event.key >= '1' && event.key <= '9') {
                        updateSudokuCell(Number(event.key));
                        event.preventDefault();
                        return;
                    }
                    if (event.key === 'Backspace' || event.key === 'Delete' || event.key === '0') {
                        updateSudokuCell(0);
                        event.preventDefault();
                    }
                });
                sudokuKeyboardBound = true;
            }
        }

        function renderSudoku() {
            if (!sudokuGridEl) return;
            const solvedBlocks = getSudokuSolvedBlocks();
            sudokuGridEl.innerHTML = '';
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const val = sudokuState[r][c];
                    const cell = document.createElement('button');
                    cell.type = 'button';
                    cell.className = 'sudoku-cell';
                    cell.dataset.r = String(r);
                    cell.dataset.c = String(c);

                    if (SUDOKU_PUZZLE[r][c] !== 0) {
                        cell.classList.add('fixed');
                        cell.textContent = String(SUDOKU_PUZZLE[r][c]);
                        cell.disabled = true;
                    } else {
                        if (val) cell.textContent = String(val);
                    }

                    const blockIndex = Math.floor(r / 3) * 3 + Math.floor(c / 3);
                    if (solvedBlocks[blockIndex]) {
                        cell.classList.add('revealed');
                        if (!sudokuRevealedBlocks.has(blockIndex)) {
                            cell.classList.add('reveal-in');
                        }
                        cell.style.backgroundImage = "url('images/Sudoku.jpg')";
                        cell.style.backgroundSize = '900% 900%';
                        cell.style.backgroundPosition = `${(c / 8) * 100}% ${(r / 8) * 100}%`;
                    }

                    if (sudokuActive && sudokuActive.r === r && sudokuActive.c === c) {
                        cell.classList.add('active');
                    }

                    sudokuGridEl.appendChild(cell);
                }
            }

            solvedBlocks.forEach((isSolved, blockIndex) => {
                if (isSolved) sudokuRevealedBlocks.add(blockIndex);
            });

            if (checkSudokuSolved()) {
                sudokuGridEl.classList.add('complete');
            } else {
                sudokuGridEl.classList.remove('complete');
            }
        }

        function getSudokuSolvedBlocks() {
            const solved = Array(9).fill(true);
            for (let block = 0; block < 9; block++) {
                const startRow = Math.floor(block / 3) * 3;
                const startCol = (block % 3) * 3;
                const seen = new Set();
                for (let r = startRow; r < startRow + 3; r++) {
                    for (let c = startCol; c < startCol + 3; c++) {
                        const value = sudokuState[r][c];
                        if (!value || value < 1 || value > 9) {
                            solved[block] = false;
                            continue;
                        }
                        seen.add(value);
                    }
                }
                if (seen.size !== 9) solved[block] = false;
            }
            return solved;
        }

        function renderSudokuKeypad() {
            if (!sudokuKeypadEl) return;
            sudokuKeypadEl.innerHTML = '';
            for (let i = 1; i <= 9; i++) {
                const key = document.createElement('button');
                key.type = 'button';
                key.className = 'sudoku-key';
                key.dataset.value = String(i);
                key.textContent = String(i);
                sudokuKeypadEl.appendChild(key);
            }
            const clear = document.createElement('button');
            clear.type = 'button';
            clear.className = 'sudoku-key clear';
            clear.dataset.action = 'clear';
            clear.textContent = 'Clear';
            sudokuKeypadEl.appendChild(clear);
        }

        function updateSudokuCell(value) {
            if (!sudokuActive) {
                if (sudokuMessageEl) sudokuMessageEl.textContent = 'Tap a square first.';
                return;
            }
            const { r, c } = sudokuActive;
            if (SUDOKU_PUZZLE[r][c] !== 0) return;
            sudokuState[r][c] = value;
            if (sudokuMessageEl) sudokuMessageEl.textContent = '';
            renderSudoku();
            if (checkSudokuSolved()) {
                if (sudokuMessageEl) sudokuMessageEl.textContent = 'Solved! üíï';
                runStreamersFor(2000);
                setTimeout(() => {
                    if (sudokuView && minesweeperView) {
                        switchView(sudokuView, minesweeperView, true);
                        initMinesweeper();
                    }
                }, 4000);
            }
        }

        function checkSudokuSolved() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (sudokuState[r][c] !== SUDOKU_SOLUTION[r][c]) return false;
                }
            }
            return true;
        }

        // --- Minesweeper logic ---
        let minesweeperBound = false;

        function initMinesweeper() {
            minesweeperCells = [];
            minesweeperFlagMode = false;
            minesweeperGameOver = false;
            minesweeperRevealedCount = 0;
            if (minesweeperMessageEl) minesweeperMessageEl.textContent = '';
            if (minesweeperFlagBtn) minesweeperFlagBtn.textContent = 'Flag Mode: Off';
            buildMinesweeperGrid();
            renderMinesweeper();

            if (!minesweeperBound) {
                if (minesweeperGridEl) {
                    minesweeperGridEl.addEventListener('click', (event) => {
                        const cell = event.target.closest('.minesweeper-cell');
                        if (!cell) return;
                        const r = Number(cell.dataset.r);
                        const c = Number(cell.dataset.c);
                        if (minesweeperFlagMode) {
                            toggleMinesweeperFlag(r, c);
                        } else {
                            revealMinesweeperCell(r, c);
                        }
                    });
                    minesweeperGridEl.addEventListener('contextmenu', (event) => {
                        const cell = event.target.closest('.minesweeper-cell');
                        if (!cell) return;
                        event.preventDefault();
                        const r = Number(cell.dataset.r);
                        const c = Number(cell.dataset.c);
                        toggleMinesweeperFlag(r, c);
                    });
                }

                if (minesweeperFlagBtn) {
                    minesweeperFlagBtn.addEventListener('click', () => {
                        minesweeperFlagMode = !minesweeperFlagMode;
                        minesweeperFlagBtn.textContent = minesweeperFlagMode ? 'Flag Mode: On' : 'Flag Mode: Off';
                    });
                }

                if (minesweeperResetBtn) {
                    minesweeperResetBtn.addEventListener('click', () => {
                        initMinesweeper();
                    });
                }

                minesweeperBound = true;
            }
        }

        function buildMinesweeperGrid() {
            minesweeperCells = Array.from({ length: MINESWEEPER_ROWS }, () =>
                Array.from({ length: MINESWEEPER_COLS }, () => ({
                    mine: false,
                    count: 0,
                    revealed: false,
                    flagged: false
                }))
            );

            let placed = 0;
            while (placed < MINESWEEPER_MINES) {
                const r = Math.floor(Math.random() * MINESWEEPER_ROWS);
                const c = Math.floor(Math.random() * MINESWEEPER_COLS);
                if (minesweeperCells[r][c].mine) continue;
                minesweeperCells[r][c].mine = true;
                placed += 1;
            }

            for (let r = 0; r < MINESWEEPER_ROWS; r++) {
                for (let c = 0; c < MINESWEEPER_COLS; c++) {
                    if (minesweeperCells[r][c].mine) continue;
                    minesweeperCells[r][c].count = countAdjacentMines(r, c);
                }
            }
        }

        function countAdjacentMines(row, col) {
            let count = 0;
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const rr = row + dr;
                    const cc = col + dc;
                    if (rr < 0 || rr >= MINESWEEPER_ROWS || cc < 0 || cc >= MINESWEEPER_COLS) continue;
                    if (minesweeperCells[rr][cc].mine) count += 1;
                }
            }
            return count;
        }

        function renderMinesweeper() {
            if (!minesweeperGridEl) return;
            minesweeperGridEl.innerHTML = '';
            minesweeperGridEl.style.gridTemplateColumns = `repeat(${MINESWEEPER_COLS}, 1fr)`;
            for (let r = 0; r < MINESWEEPER_ROWS; r++) {
                for (let c = 0; c < MINESWEEPER_COLS; c++) {
                    const cellData = minesweeperCells[r][c];
                    const cell = document.createElement('button');
                    cell.type = 'button';
                    cell.className = 'minesweeper-cell';
                    cell.dataset.r = String(r);
                    cell.dataset.c = String(c);

                    if (cellData.revealed) {
                        cell.classList.add('revealed');
                        if (cellData.mine) {
                            cell.classList.add('mine');
                            cell.textContent = 'üí£';
                        } else if (cellData.count > 0) {
                            cell.textContent = String(cellData.count);
                        }
                    } else if (cellData.flagged) {
                        cell.classList.add('flagged');
                        cell.textContent = 'üö©';
                    }

                    if (minesweeperGameOver) {
                        cell.disabled = true;
                    }

                    minesweeperGridEl.appendChild(cell);
                }
            }
        }

        function toggleMinesweeperFlag(row, col) {
            if (minesweeperGameOver) return;
            const cell = minesweeperCells[row][col];
            if (cell.revealed) return;
            cell.flagged = !cell.flagged;
            renderMinesweeper();
        }

        function revealMinesweeperCell(row, col) {
            if (minesweeperGameOver) return;
            const cell = minesweeperCells[row][col];
            if (cell.revealed || cell.flagged) return;

            cell.revealed = true;
            if (cell.mine) {
                minesweeperGameOver = true;
                revealAllMines();
                if (minesweeperMessageEl) minesweeperMessageEl.textContent = 'Boom! Try again. üí•';
                return;
            }

            minesweeperRevealedCount += 1;
            if (cell.count === 0) floodReveal(row, col);
            renderMinesweeper();
            checkMinesweeperWin();
        }

        function floodReveal(row, col) {
            const queue = [{ r: row, c: col }];
            while (queue.length) {
                const { r, c } = queue.shift();
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const rr = r + dr;
                        const cc = c + dc;
                        if (rr < 0 || rr >= MINESWEEPER_ROWS || cc < 0 || cc >= MINESWEEPER_COLS) continue;
                        const neighbor = minesweeperCells[rr][cc];
                        if (neighbor.revealed || neighbor.flagged || neighbor.mine) continue;
                        neighbor.revealed = true;
                        minesweeperRevealedCount += 1;
                        if (neighbor.count === 0) queue.push({ r: rr, c: cc });
                    }
                }
            }
        }

        function revealAllMines() {
            for (let r = 0; r < MINESWEEPER_ROWS; r++) {
                for (let c = 0; c < MINESWEEPER_COLS; c++) {
                    const cell = minesweeperCells[r][c];
                    if (cell.mine) cell.revealed = true;
                }
            }
            renderMinesweeper();
        }

        function checkMinesweeperWin() {
            const totalSafe = MINESWEEPER_ROWS * MINESWEEPER_COLS - MINESWEEPER_MINES;
            if (minesweeperRevealedCount >= totalSafe) {
                minesweeperGameOver = true;
                if (minesweeperMessageEl) minesweeperMessageEl.textContent = 'You cleared it! üíï';
                runStreamersFor(2000);
                setTimeout(() => {
                    if (minesweeperView && questionView) switchView(minesweeperView, questionView, true);
                }, 800);
            }
        }

        // --- Wordsearch logic ---
        let WORDS = ['LOVELY','BEAUTIFUL','GORGEOUS','AMAZING','VALENTINE','PRETTY','SWEET','CUTE','MINE','KIND'];
        let gridRows = 12, gridCols = 12;
        let grid = [];
        let owners = [];// parallel 2D array: list of word indices owning each cell
        let ownersUsedCount = [];// parallel 2D array: how many owning words have been found/used
        let selected = [];
        let foundWords = new Set();

        // Core generator: builds one candidate grid
        function generateWordsearchOnce() {
            // initialize empty grid, owners and ownersUsedCount
            grid = Array.from({length: gridRows}, () => Array(gridCols).fill(''));
            owners = Array.from({length: gridRows}, () => Array.from({length: gridCols}, () => []));
            ownersUsedCount = Array.from({length: gridRows}, () => Array.from({length: gridCols}, () => 0));

            // Force certain words to be diagonal (place these first)
            const words = WORDS.slice();
            const diagList = ['VALENTINE','PRETTY','SWEET','CUTE','KIND'];
            const diagIndices = new Set();
            words.forEach((w, i) => {
                const up = w.toUpperCase();
                if (diagList.includes(up)) diagIndices.add(i);
            });

            // place diagonal words first, then the rest
            const order = [];
            diagIndices.forEach(i => order.push(i));
            for (let i = 0; i < words.length; i++) if (!diagIndices.has(i)) order.push(i);

            for (const wi of order) {
                const rawWord = words[wi];
                const word = rawWord.toUpperCase();
                let placed = false;
                const tryReverse = Math.random() < 0.5;
                const w = tryReverse ? word.split('').reverse().join('') : word;

                for (let attempt = 0; attempt < 400 && !placed; attempt++) {
                    // choose direction: across, down, or diagonal if required
                    let dir;
                    if (diagIndices.has(wi)) dir = 'diag';
                    else dir = Math.random() < 0.5 ? 'across' : 'down';

                    if (dir === 'across') {
                        const row = Math.floor(Math.random() * gridRows);
                        const maxCol = gridCols - w.length;
                        if (maxCol < 0) continue;
                        const col = Math.floor(Math.random() * (maxCol + 1));
                        let ok = true;
                        for (let i = 0; i < w.length; i++) {
                            const existing = grid[row][col + i];
                            if (existing !== '' && existing !== w[i]) { ok = false; break; }
                        }
                            if (ok) {
                                for (let i = 0; i < w.length; i++) {
                                    grid[row][col + i] = w[i];
                                    owners[row][col + i].push(wi);
                                }
                                placed = true;
                            }
                    } else if (dir === 'down') {
                        const col = Math.floor(Math.random() * gridCols);
                        const maxRow = gridRows - w.length;
                        if (maxRow < 0) continue;
                        const row = Math.floor(Math.random() * (maxRow + 1));
                        let ok = true;
                        for (let i = 0; i < w.length; i++) {
                            const existing = grid[row + i][col];
                            if (existing !== '' && existing !== w[i]) { ok = false; break; }
                        }
                        if (ok) {
                            for (let i = 0; i < w.length; i++) {
                                grid[row + i][col] = w[i];
                                owners[row + i][col].push(wi);
                            }
                            placed = true;
                        }
                    } else if (dir === 'diag') {
                        const diagDirs = [ {dr:1,dc:1}, {dr:1,dc:-1}, {dr:-1,dc:1}, {dr:-1,dc:-1} ];
                        const d = diagDirs[Math.floor(Math.random() * diagDirs.length)];
                        let rowStartMin = d.dr === 1 ? 0 : w.length - 1;
                        let rowStartMax = d.dr === 1 ? gridRows - w.length : gridRows - 1;
                        let colStartMin = d.dc === 1 ? 0 : w.length - 1;
                        let colStartMax = d.dc === 1 ? gridCols - w.length : gridCols - 1;
                        if (rowStartMax < rowStartMin || colStartMax < colStartMin) continue;
                        const row = Math.floor(Math.random() * (rowStartMax - rowStartMin + 1)) + rowStartMin;
                        const col = Math.floor(Math.random() * (colStartMax - colStartMin + 1)) + colStartMin;
                        let ok = true;
                        for (let i = 0; i < w.length; i++) {
                            const rr = row + i * d.dr;
                            const cc = col + i * d.dc;
                            const existing = grid[rr][cc];
                            if (existing !== '' && existing !== w[i]) { ok = false; break; }
                        }
                        if (ok) {
                            for (let i = 0; i < w.length; i++) {
                                const rr = row + i * d.dr;
                                const cc = col + i * d.dc;
                                grid[rr][cc] = w[i];
                                owners[rr][cc].push(wi);
                            }
                            placed = true;
                        }
                    }
                }

                if (!placed) {
                    // If this word was required to be diagonal, try systematic diagonal placements before falling back to across
                    if (diagIndices && diagIndices.has(wi)) {
                        const diagDirs = [ {dr:1,dc:1}, {dr:1,dc:-1}, {dr:-1,dc:1}, {dr:-1,dc:-1} ];
                        outerDiag: for (const d of diagDirs) {
                            for (let r = 0; r < gridRows; r++) {
                                for (let c = 0; c < gridCols; c++) {
                                    const rowStartMin = d.dr === 1 ? 0 : word.length - 1;
                                    const rowStartMax = d.dr === 1 ? gridRows - word.length : gridRows - 1;
                                    const colStartMin = d.dc === 1 ? 0 : word.length - 1;
                                    const colStartMax = d.dc === 1 ? gridCols - word.length : gridCols - 1;
                                    if (r < rowStartMin || r > rowStartMax || c < colStartMin || c > colStartMax) continue;
                                    let ok = true;
                                    for (let i = 0; i < word.length; i++) {
                                        const rr = r + i * d.dr;
                                        const cc = c + i * d.dc;
                                        const existing = grid[rr][cc];
                                        if (existing !== '' && existing !== (tryReverse ? w[i] : w[i])) { ok = false; break; }
                                    }
                                    if (ok) {
                                        for (let i = 0; i < word.length; i++) {
                                            const rr = r + i * d.dr;
                                            const cc = c + i * d.dc;
                                            grid[rr][cc] = w[i];
                                            owners[rr][cc].push(wi);
                                        }
                                        placed = true;
                                        break outerDiag;
                                    }
                                }
                            }
                        }
                    }

                    // fallback: try across placement
                    if (!placed) {
                        outer: for (let r = 0; r < gridRows; r++) {
                            for (let c = 0; c <= gridCols - word.length; c++) {
                                let ok = true;
                                for (let i = 0; i < word.length; i++) {
                                    const existing = grid[r][c + i];
                                    if (existing !== '' && existing !== word[i]) { ok = false; break; }
                                }
                                if (ok) {
                                    for (let i = 0; i < word.length; i++) {
                                        grid[r][c + i] = word[i];
                                        owners[r][c + i].push(wi);
                                    }
                                    placed = true;
                                    break outer;
                                }
                            }
                        }
                    }
                }
            }

            // fill remaining empty cells with random letters
            for (let r = 0; r < gridRows; r++) for (let c = 0; c < gridCols; c++) if (!grid[r][c]) grid[r][c] = randomLetter();
        }

        function randomLetter() { return String.fromCharCode(65 + Math.floor(Math.random()*26)); }

        // Helpers to verify that every word actually appears in the grid
        function checkDiagonalInGrid(word) {
            const diagDirs = [
                {dr: 1, dc: 1},
                {dr: 1, dc: -1},
                {dr: -1, dc: 1},
                {dr: -1, dc: -1}
            ];
            for (let startR = 0; startR < gridRows; startR++) {
                for (let startC = 0; startC < gridCols; startC++) {
                    for (const {dr, dc} of diagDirs) {
                        let found = '';
                        for (let i = 0; i < word.length; i++) {
                            const r = startR + i * dr;
                            const c = startC + i * dc;
                            if (r < 0 || r >= gridRows || c < 0 || c >= gridCols) break;
                            found += grid[r][c];
                        }
                        if (found === word || found === word.split('').reverse().join('')) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function checkWordInGrid(word) {
            word = word.toUpperCase();
            const reversed = word.split('').reverse().join('');

            // horizontal
            for (let r = 0; r < gridRows; r++) {
                for (let c = 0; c <= gridCols - word.length; c++) {
                    let found = '';
                    for (let i = 0; i < word.length; i++) found += grid[r][c + i];
                    if (found === word || found === reversed) return true;
                }
            }

            // vertical
            for (let c = 0; c < gridCols; c++) {
                for (let r = 0; r <= gridRows - word.length; r++) {
                    let found = '';
                    for (let i = 0; i < word.length; i++) found += grid[r + i][c];
                    if (found === word || found === reversed) return true;
                }
            }

            // diagonal
            return checkDiagonalInGrid(word);
        }

        function allWordsPresentInGrid() {
            return WORDS.every(w => checkWordInGrid(w));
        }

        // Public initializer: keep regenerating until every word is present (with a safety cap)
        function initWordsearch() {
            const maxAttempts = 30;
            let attempts = 0;
            do {
                generateWordsearchOnce();
                attempts++;
            } while (!allWordsPresentInGrid() && attempts < maxAttempts);

            renderWordGrid();
            renderWordList();
            document.getElementById('clearSelectionBtn').onclick = clearSelection;
            setupDragHandlers();
        }

        function placeWord(word, row, col, dir) {
            word = word.toUpperCase();
            if (dir === 'across') {
                for (let i=0;i<word.length;i++) grid[row][col+i] = word[i];
            } else if (dir === 'down') {
                for (let i=0;i<word.length;i++) grid[row+i][col] = word[i];
            }
        }

        function renderWordGrid() {
            const wrap = document.getElementById('wordGrid');
            wrap.innerHTML = '';
            for (let r=0;r<gridRows;r++) {
                for (let c=0;c<gridCols;c++) {
                    const ch = grid[r][c];
                    const cell = document.createElement('div');
                    cell.className = 'word-cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.textContent = ch;
                    // mark shared cells visually
                    // shared cells are only shown after they've been used twice (ownersUsedCount>=2)
                    // DOM will be updated when words are found.
                    // small click fallback: select single cell
                    cell.addEventListener('click', (e) => {
                        if (isDragging) return; // ignore click that is part of drag
                        clearSelection();
                        addCellToSelection(cell, r, c);
                        finalizeSelection();
                    });
                    wrap.appendChild(cell);
                }
            }
            selected = [];
            updateSelectionDisplay();
        }

        function renderWordList() {
            const ul = document.getElementById('wordList');
            Array.from(ul.querySelectorAll('li')).forEach(li => li.classList.remove('found'));
            foundWords.clear();
        }

        function onCellClick(cell, r, c) {
            // allow selecting a cell even if it's been marked found, provided
            // it belongs to at least one word that is not yet found.
            const cellOwners = (owners && owners[r] && owners[r][c]) ? owners[r][c] : [];
            const allOwnersFound = cellOwners.length > 0 && cellOwners.every(idx => foundWords.has(WORDS[idx]));
            if (allOwnersFound) return;

            // toggle selection if last clicked is same
            const key = r+','+c;
            if (selected.length > 0 && selected.some(s => s.key === key)) return; // ignore duplicates

            // enforce adjacency for subsequent selections
            if (selected.length > 0) {
                const last = selected[selected.length-1];
                const dr = Math.abs(last.r - r), dc = Math.abs(last.c - c);
                if (dr > 1 || dc > 1) return; // must be adjacent
            }

            selected.push({r,c,cell,key});
            cell.classList.add('selected');
            updateSelectionDisplay();
            checkSelectionMatch();
        }

        function updateSelectionDisplay() {
            const text = selected.map(s => s.cell.textContent).join('');
            document.getElementById('currentSelection').textContent = 'Selected: ' + text;
        }

        function clearSelection() {
            selected.forEach(s => s.cell.classList.remove('selected'));
            selected = [];
            updateSelectionDisplay();
        }

        // --- Drag-to-select support ---
        let isDragging = false;
        let dragStart = null; // {r,c}
        let dragDir = null; // {dr,dc}

        function addCellToSelection(cell, r, c) {
            const key = r+','+c;
            if (selected.some(s => s.key === key)) return;
            // don't add if all owners of this cell are already found
            const cellOwners = (owners && owners[r] && owners[r][c]) ? owners[r][c] : [];
            const allOwnersFound = cellOwners.length > 0 && cellOwners.every(idx => foundWords.has(WORDS[idx]));
            if (allOwnersFound) return;
            selected.push({r,c,cell,key});
            cell.classList.add('selected');
            updateSelectionDisplay();
        }

        function trimSelectionTo(key) {
            const idx = selected.findIndex(s => s.key === key);
            if (idx === -1) return;
            // remove extras
            for (let i = selected.length - 1; i > idx; i--) {
                selected[i].cell.classList.remove('selected');
                selected.pop();
            }
            updateSelectionDisplay();
        }

        function finalizeSelection() {
            checkSelectionMatch();
        }

        function cellFromPoint(x, y) {
            const el = document.elementFromPoint(x, y);
            if (!el) return null;
            if (el.classList && el.classList.contains('word-cell')) return el;
            return el.closest && el.closest('.word-cell');
        }

        function onPointerDown(e) {
            if (e.button && e.button !== 0) return; // only left
            const cell = cellFromPoint(e.clientX, e.clientY);
            if (!cell) return;
            isDragging = true;
            dragStart = { r: Number(cell.dataset.r), c: Number(cell.dataset.c) };
            dragDir = null;
            clearSelection();
            addCellToSelection(cell, dragStart.r, dragStart.c);
            document.body.style.userSelect = 'none';
            e.preventDefault();
        }

        function onPointerMove(e) {
            if (!isDragging) return;
            const cell = cellFromPoint(e.clientX, e.clientY);
            if (!cell) return;
            const r = Number(cell.dataset.r), c = Number(cell.dataset.c);
            const start = dragStart;
            if (!start) return;
            const dr = r - start.r, dc = c - start.c;
            if (dr === 0 && dc === 0) {
                // already at start
                return;
            }
            // determine direction unit vector with components in {-1,0,1}
            const stepR = dr === 0 ? 0 : (dr > 0 ? 1 : -1);
            const stepC = dc === 0 ? 0 : (dc > 0 ? 1 : -1);
            // check that target cell lies on straight line from start along (stepR,stepC)
            // i.e., steps must be consistent: either horizontal, vertical, or diagonal
            const steps = Math.max(Math.abs(dr), Math.abs(dc));
            if ( (stepR !== 0 && stepC !== 0 && Math.abs(dr) !== Math.abs(dc)) ) {
                // not a 45deg diagonal
                return;
            }
            // set dragDir on first move
            if (!dragDir) dragDir = { dr: stepR, dc: stepC };
            // ensure current direction matches established direction
            if (dragDir.dr !== stepR || dragDir.dc !== stepC) return;

            // target key
            const targetKey = start.r + ',' + start.c;
            const targetR = start.r + steps * dragDir.dr;
            const targetC = start.c + steps * dragDir.dc;
            const targetKey2 = targetR + ',' + targetC;

            // if cell already in selection and not last, trim
            if (selected.some(s => s.key === targetKey2)) {
                trimSelectionTo(targetKey2);
                return;
            }

            // otherwise add missing intermediate cells along the line
            let curLen = selected.length;
            for (let k = curLen; k <= steps; k++) {
                const rr = start.r + k * dragDir.dr;
                const cc = start.c + k * dragDir.dc;
                const el = document.querySelector('.word-cell[data-r="' + rr + '"][data-c="' + cc + '"]');
                if (!el) break;
                addCellToSelection(el, rr, cc);
            }
        }

        function onPointerUp(e) {
            if (!isDragging) return;
            isDragging = false;
            dragStart = null;
            dragDir = null;
            document.body.style.userSelect = '';
            finalizeSelection();
        }

        function setupDragHandlers() {
            const gridEl = document.getElementById('wordGrid');
            gridEl.addEventListener('pointerdown', onPointerDown);
            gridEl.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            // prevent default touch behaviors
            gridEl.style.touchAction = 'none';
        }

        function checkSelectionMatch() {
            const word = selected.map(s => s.cell.textContent).join('');
            const rev = word.split('').reverse().join('');
            for (const target of WORDS) {
                if (foundWords.has(target)) continue;
                if (word === target || rev === target) {
                    // mark found
                    // mark all selected cells as found for this word
                    selected.forEach(s => {
                        s.cell.classList.remove('selected');
                        s.cell.classList.add('found');
                    });

                    // update ownersUsedCount for every cell that this word owns
                    const wordIndex = WORDS.indexOf(target);
                    if (wordIndex !== -1) {
                        for (let rr = 0; rr < gridRows; rr++) {
                            for (let cc = 0; cc < gridCols; cc++) {
                                if (owners[rr][cc] && owners[rr][cc].includes(wordIndex)) {
                                    ownersUsedCount[rr][cc] = (ownersUsedCount[rr][cc] || 0) + 1;
                                    // when a cell's ownersUsedCount reaches 2, mark it visually as shared
                                    if (ownersUsedCount[rr][cc] >= 2) {
                                        const el = document.querySelector('.word-cell[data-r="' + rr + '"][data-c="' + cc + '"]');
                                        if (el) el.classList.add('shared');
                                    }
                                }
                            }
                        }
                    }

                    const li = Array.from(document.getElementById('wordList').children).find(x => x.dataset.word === target);
                    if (li) li.classList.add('found');
                    foundWords.add(target);
                    selected = [];
                    updateSelectionDisplay();
                    if (foundWords.size === WORDS.length) completeWordsearch();
                    return;
                }
            }
        }

        function completeWordsearch() {
            // hide the wordsearch and show the Wordle view
            runStreamersFor(2000);
            const wordsearchView = document.getElementById('wordsearchView');
            if (wordsearchView && wordleView) {
                switchView(wordsearchView, wordleView, true);
                initWordle();
            } else if (questionView) {
                questionView.classList.add('visible');
            }
        }
        
        function runConfettiFor(ms, intensity) {
            const end = Date.now() + ms;
            const start = Date.now();
            function tick() {
                const now = Date.now();
                if (now < end) {
                    const progress = (now - start) / ms;
                    const currentIntensity = Math.ceil(intensity * (1 - progress));
                    for (let i = 0; i < currentIntensity; i++) {
                        createConfetti(end - now);
                    }
                    setTimeout(tick, 80);
                }
            }
            tick();
        }
        
        function createConfetti(timeLeft) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.textContent = ['üíã', 'üåπ', '‚ô•Ô∏è'][Math.floor(Math.random() * 3)];
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.top = '-40px';
            const duration = 3 + Math.random() * 3;
            confetti.style.animation = `confetti-fall ${duration}s linear`;
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), (duration + 0.5) * 1000);
        }

        function runStreamersFor(ms) {
            const end = Date.now() + ms;
            function tick() {
                if (Date.now() < end) {
                    createStreamer();
                    setTimeout(tick, 100);
                }
            }
            tick();
        }

        function createStreamer() {
            const streamer = document.createElement('div');
            streamer.className = 'streamer';
            const emojis = ['üíã', 'üíï', '‚ú®', 'üéÄ'];
            streamer.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            streamer.style.left = Math.random() * 95 + '%';
            streamer.style.top = '-50px';
            const duration = 3 + Math.random() * 1.5;
            streamer.style.animation = `streamer-fall ${duration}s ease-in`;
            document.body.appendChild(streamer);
            setTimeout(() => streamer.remove(), (duration + 0.2) * 1000);
        }
    </script>
</body>
</html>